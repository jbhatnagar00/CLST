// src/shared/security/sanitization.ts
import DOMPurify from 'dompurify';
import { z } from 'zod';

export class InputSanitizer {
  // Sanitize HTML content
  static sanitizeHTML(dirty: string): string {
    return DOMPurify.sanitize(dirty, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
      ALLOWED_ATTR: ['href', 'title', 'target'],
    });
  }

  // Sanitize user input
  static sanitizeInput(input: string): string {
    return input
      .trim()
      .replace(/[<>]/g, '') // Remove potential HTML
      .replace(/javascript:/gi, '') // Remove javascript: protocols
      .replace(/on\w+\s*=/gi, ''); // Remove event handlers
  }

  // Sanitize SQL-like inputs
  static sanitizeSQL(input: string): string {
    return input
      .replace(/['";\\]/g, '') // Remove quotes and backslashes
      .replace(/--/g, '') // Remove SQL comments
      .replace(/\/\*/g, '') // Remove multi-line comments
      .replace(/\*\//g, '');
  }

  // Sanitize file names
  static sanitizeFileName(fileName: string): string {
    return fileName
      .replace(/[^a-zA-Z0-9.-]/g, '_') // Replace invalid chars
      .replace(/\.{2,}/g, '.') // Remove multiple dots
      .substring(0, 255); // Limit length
  }

  // Validate and sanitize URLs
  static sanitizeURL(url: string): string | null {
    try {
      const parsed = new URL(url);
      // Only allow http(s) protocols
      if (!['http:', 'https:'].includes(parsed.protocol)) {
        return null;
      }
      return parsed.toString();
    } catch {
      return null;
    }
  }
}

// Input validation schemas
export const validationSchemas = {
  // User input schemas
  userRegistration: z.object({
    email: z.string().email().max(255),
    username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
    password: z.string().min(8).max(128)
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/),
    firstName: z.string().min(1).max(50),
    lastName: z.string().min(1).max(50),
  }),

  // Closet item schemas
  clothingItem: z.object({
    name: z.string().min(1).max(100).transform(InputSanitizer.sanitizeInput),
    category: z.enum(['tops', 'bottoms', 'dresses', 'outerwear', 'shoes', 'accessories', 'underwear', 'activewear', 'swimwear', 'other']),
    brand: z.string().max(50).optional().transform(v => v ? InputSanitizer.sanitizeInput(v) : undefined),
    size: z.string().max(20).optional(),
    price: z.number().min(0).max(999999).optional(),
    notes: z.string().max(500).optional().transform(v => v ? InputSanitizer.sanitizeHTML(v) : undefined),
    tags: z.array(z.string().max(30)).max(20),
  }),

  // Marketplace listing schemas
  listing: z.object({
    title: z.string().min(5).max(100).transform(InputSanitizer.sanitizeInput),
    description: z.string().min(10).max(2000).transform(InputSanitizer.sanitizeHTML),
    price: z.number().min(0.01).max(99999),
    condition: z.enum(['new-with-tags', 'new-without-tags', 'excellent', 'good', 'fair']),
    size: z.string().max(20),
    shipping: z.object({
      domestic: z.number().min(0).max(1000),
      international: z.number().min(0).max(1000).optional(),
    }),
  }),
};

// XSS Protection Hook
// src/shared/hooks/useSecureContent.ts
import { useMemo } from 'react';
import { InputSanitizer } from '@/shared/security/sanitization';

export function useSecureContent(content: string, type: 'html' | 'text' = 'text') {
  return useMemo(() => {
    if (type === 'html') {
      return InputSanitizer.sanitizeHTML(content);
    }
    return InputSanitizer.sanitizeInput(content);
  }, [content, type]);
}

// CSRF Protection
// src/shared/security/csrf.ts
export class CSRFProtection {
  private static TOKEN_KEY = 'csrf_token';
  private static TOKEN_HEADER = 'X-CSRF-Token';

  static generateToken(): string {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  static getToken(): string {
    let token = sessionStorage.getItem(this.TOKEN_KEY);
    if (!token) {
      token = this.generateToken();
      sessionStorage.setItem(this.TOKEN_KEY, token);
    }
    return token;
  }

  static addToRequest(headers: HeadersInit): HeadersInit {
    return {
      ...headers,
      [this.TOKEN_HEADER]: this.getToken(),
    };
  }

  static validateToken(token: string): boolean {
    const storedToken = sessionStorage.getItem(this.TOKEN_KEY);
    return storedToken === token && token.length === 64;
  }
}

// Secure Authentication Service
// src/features/auth/services/secureAuth.ts
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import speakeasy from 'speakeasy';
import { z } from 'zod';

export class SecureAuthService {
  private static readonly JWT_SECRET = process.env.JWT_SECRET!;
  private static readonly JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;
  private static readonly ACCESS_TOKEN_EXPIRY = '15m';
  private static readonly REFRESH_TOKEN_EXPIRY = '7d';
  private static readonly PASSWORD_SALT_ROUNDS = 12;

  // Password hashing
  static async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, this.PASSWORD_SALT_ROUNDS);
  }

  static async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  // JWT token management
  static generateTokens(userId: string, email: string): {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  } {
    const payload = { userId, email };
    
    const accessToken = jwt.sign(payload, this.JWT_SECRET, {
      expiresIn: this.ACCESS_TOKEN_EXPIRY,
      issuer: 'clst',
      audience: 'clst-app',
    });

    const refreshToken = jwt.sign(payload, this.JWT_REFRESH_SECRET, {
      expiresIn: this.REFRESH_TOKEN_EXPIRY,
      issuer: 'clst',
    });

    return {
      accessToken,
      refreshToken,
      expiresIn: 15 * 60, // 15 minutes in seconds
    };
  }

  static verifyAccessToken(token: string): { userId: string; email: string } | null {
    try {
      const decoded = jwt.verify(token, this.JWT_SECRET, {
        issuer: 'clst',
        audience: 'clst-app',
      }) as any;
      return { userId: decoded.userId, email: decoded.email };
    } catch {
      return null;
    }
  }

  static verifyRefreshToken(token: string): { userId: string; email: string } | null {
    try {
      const decoded = jwt.verify(token, this.JWT_REFRESH_SECRET, {
        issuer: 'clst',
      }) as any;
      return { userId: decoded.userId, email: decoded.email };
    } catch {
      return null;
    }
  }

  // Two-factor authentication
  static generate2FASecret(email: string): {
    secret: string;
    qrCode: string;
  } {
    const secret = speakeasy.generateSecret({
      name: `CLST (${email})`,
      issuer: 'CLST Fashion',
      length: 32,
    });

    return {
      secret: secret.base32,
      qrCode: secret.otpauth_url || '',
    };
  }

  static verify2FAToken(secret: string, token: string): boolean {
    return speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token,
      window: 2, // Allow 2 time steps for clock drift
    });
  }

  // Session management
  static createSecureSession(userId: string): string {
    const sessionId = crypto.randomUUID();
    const sessionData = {
      userId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
    };
    
    // Store in secure session storage (Redis in production)
    sessionStorage.setItem(`session_${sessionId}`, JSON.stringify(sessionData));
    
    return sessionId;
  }

  static validateSession(sessionId: string): boolean {
    const sessionData = sessionStorage.getItem(`session_${sessionId}`);
    if (!sessionData) return false;

    const session = JSON.parse(sessionData);
    const now = Date.now();
    const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes

    if (now - session.lastActivity > SESSION_TIMEOUT) {
      sessionStorage.removeItem(`session_${sessionId}`);
      return false;
    }

    // Update last activity
    session.lastActivity = now;
    sessionStorage.setItem(`session_${sessionId}`, JSON.stringify(session));
    
    return true;
  }
}

// Data Encryption Service
// src/shared/security/encryption.ts
export class EncryptionService {
  private static readonly ALGORITHM = 'AES-GCM';
  private static readonly KEY_LENGTH = 256;
  private static readonly IV_LENGTH = 12;
  private static readonly TAG_LENGTH = 16;

  // Generate encryption key
  static async generateKey(): Promise<CryptoKey> {
    return crypto.subtle.generateKey(
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH,
      },
      true,
      ['encrypt', 'decrypt']
    );
  }

  // Encrypt sensitive data
  static async encrypt(data: string, key: CryptoKey): Promise<{
    encrypted: ArrayBuffer;
    iv: Uint8Array;
  }> {
    const encoder = new TextEncoder();
    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
    
    const encrypted = await crypto.subtle.encrypt(
      {
        name: this.ALGORITHM,
        iv,
        tagLength: this.TAG_LENGTH * 8,
      },
      key,
      encoder.encode(data)
    );

    return { encrypted, iv };
  }

  // Decrypt data
  static async decrypt(
    encrypted: ArrayBuffer,
    key: CryptoKey,
    iv: Uint8Array
  ): Promise<string> {
    const decrypted = await crypto.subtle.decrypt(
      {
        name: this.ALGORITHM,
        iv,
        tagLength: this.TAG_LENGTH * 8,
      },
      key,
      encrypted
    );

    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
  }

  // Encrypt sensitive fields in objects
  static async encryptObject<T extends Record<string, any>>(
    obj: T,
    sensitiveFields: (keyof T)[],
    key: CryptoKey
  ): Promise<T> {
    const encrypted = { ...obj };
    
    for (const field of sensitiveFields) {
      if (obj[field]) {
        const { encrypted: encData, iv } = await this.encrypt(
          JSON.stringify(obj[field]),
          key
        );
        encrypted[field] = {
          data: btoa(String.fromCharCode(...new Uint8Array(encData))),
          iv: btoa(String.fromCharCode(...iv)),
        } as any;
      }
    }
    
    return encrypted;
  }
}

// Rate Limiting
// src/server/middleware/rateLimiter.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
});

// Different rate limits for different endpoints
export const rateLimiters = {
  // General API limit
  general: rateLimit({
    store: new RedisStore({
      client: redis,
      prefix: 'rl:general:',
    }),
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100,
    message: 'Too many requests, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
  }),

  // Auth endpoints (stricter)
  auth: rateLimit({
    store: new RedisStore({
      client: redis,
      prefix: 'rl:auth:',
    }),
    windowMs: 15 * 60 * 1000,
    max: 5,
    skipSuccessfulRequests: true,
    message: 'Too many authentication attempts.',
  }),

  // File upload endpoints
  upload: rateLimit({
    store: new RedisStore({
      client: redis,
      prefix: 'rl:upload:',
    }),
    windowMs: 60 * 60 * 1000, // 1 hour
    max: 20,
    message: 'Upload limit exceeded.',
  }),

  // Search endpoints
  search: rateLimit({
    store: new RedisStore({
      client: redis,
      prefix: 'rl:search:',
    }),
    windowMs: 1 * 60 * 1000, // 1 minute
    max: 30,
    message: 'Too many search requests.',
  }),
};

// ===== CI/CD PIPELINE =====
// .github/workflows/main.yml
name: CLST CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '18.x'
  PNPM_VERSION: '8'

jobs:
  # Code Quality Checks
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Lint code
        run: pnpm lint
        
      - name: Type check
        run: pnpm type-check
        
      - name: Check formatting
        run: pnpm format:check
        
      - name: Security audit
        run: pnpm audit --production

  # Unit and Integration Tests
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        shard: [1, 2, 3, 4]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Run tests
        run: pnpm test:ci --shard=${{ matrix.shard }}/4
        env:
          CI: true
          
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # E2E Tests
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Install Playwright
        run: pnpm exec playwright install --with-deps
        
      - name: Build application
        run: pnpm build
        env:
          VITE_API_URL: http://localhost:3000
          
      - name: Run E2E tests
        run: pnpm e2e:ci
        
      - name: Upload test artifacts
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/

  # Performance Budget Check
  performance:
    name: Performance Budget
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Build production bundle
        run: pnpm build
        
      - name: Check bundle size
        run: pnpm size-limit
        
      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v9
        with:
          configPath: './lighthouserc.json'
          uploadArtifacts: true
          temporaryPublicStorage: true

  # Build and Deploy
  deploy:
    name: Deploy
    needs: [quality, test, e2e, performance]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Build application
        run: pnpm build
        env:
          VITE_API_URL: ${{ secrets.PRODUCTION_API_URL }}
          VITE_SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          VITE_GA_ID: ${{ secrets.GA_ID }}
          
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment completed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

# Performance budget configuration
# .size-limit.json
[
  {
    "path": "dist/assets/index-*.js",
    "limit": "200 KB",
    "name": "Main bundle"
  },
  {
    "path": "dist/assets/vendor-*.js",
    "limit": "150 KB",
    "name": "Vendor bundle"
  },
  {
    "path": "dist/**/*.js",
    "limit": "500 KB",
    "name": "Total JS"
  },
  {
    "path": "dist/**/*.css",
    "limit": "50 KB",
    "name": "Total CSS"
  }
]

# Lighthouse CI configuration
# lighthouserc.json
{
  "ci": {
    "collect": {
      "url": ["http://localhost:3000/"],
      "startServerCommand": "pnpm preview",
      "numberOfRuns": 3
    },
    "assert": {
      "preset": "lighthouse:recommended",
      "assertions": {
        "categories:performance": ["error", { "minScore": 0.9 }],
        "categories:accessibility": ["error", { "minScore": 0.95 }],
        "categories:seo": ["error", { "minScore": 0.9 }],
        "categories:pwa": ["warn", { "minScore": 0.9 }],
        "first-contentful-paint": ["error", { "maxNumericValue": 2000 }],
        "interactive": ["error", { "maxNumericValue": 3500 }],
        "cumulative-layout-shift": ["error", { "maxNumericValue": 0.1 }]
      }
    },
    "upload": {
      "target": "temporary-public-storage"
    }
  }
}

// ===== MONITORING & OBSERVABILITY =====
// src/shared/monitoring/errorTracking.ts
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';
import { CaptureConsole } from '@sentry/integrations';

export function initializeErrorTracking() {
  Sentry.init({
    dsn: import.meta.env.VITE_SENTRY_DSN,
    environment: import.meta.env.MODE,
    integrations: [
      new BrowserTracing({
        routingInstrumentation: Sentry.reactRouterV6Instrumentation(
          React.useEffect,
          useLocation,
          useNavigationType,
          createRoutesFromChildren,
          matchRoutes
        ),
        tracingOrigins: ['localhost', /^\//],
      }),
      new CaptureConsole({
        levels: ['error', 'warn'],
      }),
      new Sentry.Replay({
        maskAllText: true,
        blockAllMedia: true,
        sampleRate: 0.1,
        errorSampleRate: 1.0,
      }),
    ],
    tracesSampleRate: import.meta.env.MODE === 'production' ? 0.1 : 1.0,
    release: import.meta.env.VITE_APP_VERSION,
    beforeSend(event, hint) {
      // Filter out known non-errors
      if (event.exception?.values?.[0]?.type === 'NetworkError') {
        return null;
      }
      
      // Add user context
      const user = useAuthStore.getState().user;
      if (user) {
        event.user = {
          id: user.id,
          email: user.email,
          username: user.username,
        };
      }
      
      return event;
    },
  });
}

// Performance Monitoring
// src/shared/monitoring/performance.ts
export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: Map<string, PerformanceEntry[]> = new Map();

  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  constructor() {
    this.initializeObservers();
  }

  private initializeObservers() {
    // Web Vitals
    if ('PerformanceObserver' in window) {
      // FCP, LCP
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric('paint', entry);
        }
      }).observe({ entryTypes: ['paint', 'largest-contentful-paint'] });

      // FID
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric('first-input', entry);
        }
      }).observe({ entryTypes: ['first-input'] });

      // CLS
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric('layout-shift', entry);
        }
      }).observe({ entryTypes: ['layout-shift'] });

      // Navigation timing
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric('navigation', entry);
        }
      }).observe({ entryTypes: ['navigation'] });
    }
  }

  private recordMetric(type: string, entry: PerformanceEntry) {
    if (!this.metrics.has(type)) {
      this.metrics.set(type, []);
    }
    this.metrics.get(type)!.push(entry);

    // Send to analytics
    analytics.trackPerformance({
      name: entry.name || type,
      value: entry.startTime || (entry as any).value || 0,
      unit: 'ms',
    });
  }

  measureComponent(componentName: string): () => void {
    const startMark = `${componentName}-start`;
    const endMark = `${componentName}-end`;
    const measureName = `${componentName}-render`;

    performance.mark(startMark);

    return () => {
      performance.mark(endMark);
      performance.measure(measureName, startMark, endMark);
      
      const measure = performance.getEntriesByName(measureName)[0];
      if (measure) {
        this.recordMetric('component-render', measure);
      }
    };
  }

  getMetrics(): Record<string, any> {
    const result: Record<string, any> = {};
    
    this.metrics.forEach((entries, type) => {
      result[type] = entries.map(entry => ({
        name: entry.name,
        value: entry.startTime || (entry as any).value || 0,
        duration: entry.duration,
      }));
    });
    
    return result;
  }
}

// Health Check Endpoint
// src/server/routes/health.ts
import { Router } from 'express';
import { redis } from '../services/redis';
import { db } from '../services/database';

export const healthRouter = Router();

healthRouter.get('/health', async (req, res) => {
  const checks = {
    uptime: process.uptime(),
    timestamp: new Date().toISOString(),
    status: 'ok',
    services: {
      database: 'unknown',
      redis: 'unknown',
      storage: 'unknown',
    },
  };

  try {
    // Check database
    await db.raw('SELECT 1');
    checks.services.database = 'healthy';
  } catch (error) {
    checks.services.database = 'unhealthy';
    checks.status = 'degraded';
  }

  try {
    // Check Redis
    await redis.ping();
    checks.services.redis = 'healthy';
  } catch (error) {
    checks.services.redis = 'unhealthy';
    checks.status = 'degraded';
  }

  try {
    // Check storage (Cloudinary)
    const response = await fetch('https://api.cloudinary.com/v1_1/ping');
    checks.services.storage = response.ok ? 'healthy' : 'unhealthy';
  } catch (error) {
    checks.services.storage = 'unhealthy';
    checks.status = 'degraded';
  }

  const statusCode = checks.status === 'ok' ? 200 : 503;
  res.status(statusCode).json(checks);
});

healthRouter.get('/health/live', (req, res) => {
  res.status(200).json({ status: 'alive' });
});

healthRouter.get('/health/ready', async (req, res) => {
  try {
    await db.raw('SELECT 1');
    await redis.ping();
    res.status(200).json({ status: 'ready' });
  } catch (error) {
    res.status(503).json({ status: 'not ready' });
  }
});

// Alerting System
// src/shared/monitoring/alerts.ts
interface Alert {
  type: 'error' | 'performance' | 'security' | 'business';
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  message: string;
  metadata?: Record<string, any>;
}

export class AlertingService {
  private static instance: AlertingService;
  private alertChannels: AlertChannel[] = [];

  static getInstance(): AlertingService {
    if (!AlertingService.instance) {
      AlertingService.instance = new AlertingService();
    }
    return AlertingService.instance;
  }

  constructor() {
    this.initializeChannels();
  }

  private initializeChannels() {
    // Slack integration
    if (import.meta.env.VITE_SLACK_WEBHOOK) {
      this.alertChannels.push(new SlackChannel(import.meta.env.VITE_SLACK_WEBHOOK));
    }

    // Email integration
    if (import.meta.env.VITE_ALERT_EMAIL) {
      this.alertChannels.push(new EmailChannel(import.meta.env.VITE_ALERT_EMAIL));
    }

    // PagerDuty integration
    if (import.meta.env.VITE_PAGERDUTY_KEY) {
      this.alertChannels.push(new PagerDutyChannel(import.meta.env.VITE_PAGERDUTY_KEY));
    }
  }

  async sendAlert(alert: Alert) {
    // Log to console
    console.error('[ALERT]', alert);

    // Send to Sentry
    Sentry.captureMessage(alert.title, alert.severity);

    // Send to alert channels based on severity
    const promises = this.alertChannels
      .filter(channel => this.shouldAlertChannel(channel, alert))
      .map(channel => channel.send(alert));

    await Promise.allSettled(promises);
  }

  private shouldAlertChannel(channel: AlertChannel, alert: Alert): boolean {
    // Critical alerts go to all channels
    if (alert.severity === 'critical') return true;

    // High severity goes to Slack and PagerDuty
    if (alert.severity === 'high') {
      return channel instanceof SlackChannel || channel instanceof PagerDutyChannel;
    }

    // Medium severity only goes to Slack
    if (alert.severity === 'medium') {
      return channel instanceof SlackChannel;
    }

    // Low severity is logged only
    return false;
  }

  // Predefined alert methods
  alertHighErrorRate(errorRate: number) {
    if (errorRate > 0.05) { // 5% error rate
      this.sendAlert({
        type: 'error',
        severity: errorRate > 0.1 ? 'critical' : 'high',
        title: 'High Error Rate Detected',
        message: `Error rate is ${(errorRate * 100).toFixed(2)}%`,
        metadata: { errorRate },
      });
    }
  }

  alertSlowPerformance(metric: string, value: number, threshold: number) {
    if (value > threshold) {
      this.sendAlert({
        type: 'performance',
        severity: value > threshold * 2 ? 'high' : 'medium',
        title: 'Performance Degradation',
        message: `${metric} is ${value}ms (threshold: ${threshold}ms)`,
        metadata: { metric, value, threshold },
      });
    }
  }

  alertSecurityIncident(incident: string, details?: any) {
    this.sendAlert({
      type: 'security',
      severity: 'critical',
      title: 'Security Incident',
      message: incident,
      metadata: details,
    });
  }
}

// Alert channels
abstract class AlertChannel {
  abstract send(alert: Alert): Promise<void>;
}

class SlackChannel extends AlertChannel {
  constructor(private webhookUrl: string) {
    super();
  }

  async send(alert: Alert) {
    const color = {
      low: '#36a64f',
      medium: '#ff9900',
      high: '#ff0000',
      critical: '#ff0000',
    }[alert.severity];

    await fetch(this.webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        attachments: [{
          color,
          title: alert.title,
          text: alert.message,
          fields: Object.entries(alert.metadata || {}).map(([key, value]) => ({
            title: key,
            value: String(value),
            short: true,
          })),
          footer: 'CLST Monitoring',
          ts: Math.floor(Date.now() / 1000),
        }],
      }),
    });
  }
}

// ===== DOCUMENTATION =====
// API Documentation (OpenAPI/Swagger)
// docs/api/openapi.yaml
openapi: 3.0.0
info:
  title: CLST API
  version: 1.0.0
  description: Digital closet and fashion marketplace API
  contact:
    name: CLST Support
    email: support@clst.app
servers:
  - url: https://api.clst.app/v1
    description: Production server
  - url: https://staging-api.clst.app/v1
    description: Staging server
security:
  - bearerAuth: []
paths:
  /auth/login:
    post:
      summary: User login
      tags: [Authentication]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [email, password]
              properties:
                email:
                  type: string
                  format: email
                password:
                  type: string
                  minLength: 8
      responses:
        200:
          description: Login successful
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
        401:
          description: Invalid credentials
        429:
          description: Rate limit exceeded

  /closet/items:
    get:
      summary: Get user's closet items
      tags: [Closet]
      parameters:
        - in: query
          name: page
          schema:
            type: integer
            default: 1
        - in: query
          name: limit
          schema:
            type: integer
            default: 20
            maximum: 100
        - in: query
          name: category
          schema:
            type: string
            enum: [tops, bottoms, dresses, outerwear, shoes, accessories]
      responses:
        200:
          description: Items retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ItemsResponse'

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        username:
          type: string
        profile:
          $ref: '#/components/schemas/UserProfile'

# Component Library Documentation
# Using Storybook - .storybook/main.js
module.exports = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx|mdx)'],
  addons: [
    '@storybook/addon-essentials',
    '@storybook/addon-a11y',
    '@storybook/addon-performance',
  ],
  framework: {
    name: '@storybook/react-vite',
    options: {},
  },
};

// Example component story
// src/shared/components/ui/Button/Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta = {
  title: 'UI/Button',
  component: Button,
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: 'Base button component with multiple variants and states.',
      },
    },
  },
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: 'select',
      options: ['primary', 'secondary', 'ghost', 'danger'],
    },
    size: {
      control: 'select',
      options: ['sm', 'md', 'lg'],
    },
  },
} satisfies Meta<typeof Button>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Button',
  },
};

export const Secondary: Story = {
  args: {
    variant: 'secondary',
    children: 'Button',
  },
};

export const Loading: Story = {
  args: {
    isLoading: true,
    children: 'Loading...',
  },
};

// Deployment Guide
// docs/deployment.md
# CLST Deployment Guide

## Prerequisites
- Node.js 18+
- pnpm 8+
- Docker (optional)
- Vercel CLI (for Vercel deployment)

## Environment Variables
Create a `.env.production` file with:
```bash
VITE_API_URL=https://api.clst.app
VITE_CLOUDINARY_CLOUD_NAME=your_cloud_name
VITE_WEATHER_API_KEY=your_openweather_key
VITE_SENTRY_DSN=your_sentry_dsn
VITE_GA_ID=your_google_analytics_id
VITE_MIXPANEL_TOKEN=your_mixpanel_token
```

## Build Process
```bash
# Install dependencies
pnpm install --frozen-lockfile

# Run tests
pnpm test

# Build for production
pnpm build

# Preview production build
pnpm preview
```

## Deployment Options

### Vercel (Recommended)
```bash
# Install Vercel CLI
pnpm add -g vercel

# Deploy
vercel --prod
```

### Docker
```bash
# Build image
docker build -t clst-app .

# Run container
docker run -p 3000:3000 clst-app
```

### AWS
1. Build the application
2. Upload to S3
3. Configure CloudFront
4. Set up Route53

## Post-Deployment
1. Verify health endpoints
2. Check monitoring dashboards
3. Test critical user flows
4. Monitor error rates

## Rollback Procedure
```bash
# Vercel
vercel rollback

# Docker
docker run -p 3000:3000 clst-app:previous-version
```

# Contributing Guidelines
// CONTRIBUTING.md
# Contributing to CLST

## Code of Conduct
Be respectful, inclusive, and professional.

## Development Setup
1. Fork the repository
2. Clone your fork
3. Install dependencies: `pnpm install`
4. Create a feature branch: `git checkout -b feature/your-feature`

## Code Standards
- TypeScript for all new code
- Follow ESLint rules
- Write tests for new features
- Update documentation

## Pull Request Process
1. Update CHANGELOG.md
2. Ensure all tests pass
3. Request review from maintainers
4. Squash commits before merge

## Commit Messages
Follow conventional commits:
- `feat:` New features
- `fix:` Bug fixes
- `docs:` Documentation
- `style:` Code style changes
- `refactor:` Code refactoring
- `test:` Test additions
- `chore:` Maintenance tasks

## Testing
- Unit tests for utilities
- Integration tests for features
- E2E tests for critical paths
- Minimum 80% coverage

## Documentation
- Update API docs for endpoint changes
- Add Storybook stories for new components
- Include JSDoc comments
- Update README if needed
