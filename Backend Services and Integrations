// Backend API Structure (Node.js/Express example)
// src/server/index.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { authRoutes } from './routes/auth.routes';
import { closetRoutes } from './routes/closet.routes';
import { marketplaceRoutes } from './routes/marketplace.routes';
import { challengesRoutes } from './routes/challenges.routes';
import { weatherRoutes } from './routes/weather.routes';
import { analyticsMiddleware } from './middleware/analytics';
import { errorHandler } from './middleware/errorHandler';

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
});
app.use('/api', limiter);

// Analytics middleware
app.use(analyticsMiddleware);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/closet', closetRoutes);
app.use('/api/marketplace', marketplaceRoutes);
app.use('/api/challenges', challengesRoutes);
app.use('/api/weather', weatherRoutes);

// Error handling
app.use(errorHandler);

// Example REST endpoint implementation
// src/server/routes/closet.routes.ts
import { Router } from 'express';
import { authMiddleware } from '../middleware/auth';
import { uploadMiddleware } from '../middleware/upload';
import { validateRequest } from '../middleware/validation';
import { closetController } from '../controllers/closet.controller';

export const closetRoutes = Router();

closetRoutes.use(authMiddleware); // All closet routes require auth

closetRoutes.get('/items', closetController.getItems);
closetRoutes.get('/items/:id', closetController.getItem);
closetRoutes.post('/items', 
  uploadMiddleware.array('images', 5),
  validateRequest('createItem'),
  closetController.createItem
);
closetRoutes.patch('/items/:id', 
  uploadMiddleware.array('images', 5),
  validateRequest('updateItem'),
  closetController.updateItem
);
closetRoutes.delete('/items/:id', closetController.deleteItem);
closetRoutes.post('/items/batch-delete', closetController.batchDelete);
closetRoutes.post('/items/:id/wear', closetController.incrementWearCount);
closetRoutes.get('/tags', closetController.getTags);

// ===== IMAGE UPLOAD SERVICE =====
// src/shared/services/cloudinary/cloudinaryService.ts
import { v2 as cloudinary } from 'cloudinary';

interface CloudinaryConfig {
  cloudName: string;
  apiKey: string;
  apiSecret: string;
}

export class CloudinaryService {
  private static instance: CloudinaryService;

  constructor(config: CloudinaryConfig) {
    cloudinary.config({
      cloud_name: config.cloudName,
      api_key: config.apiKey,
      api_secret: config.apiSecret,
    });
  }

  static getInstance(config?: CloudinaryConfig): CloudinaryService {
    if (!CloudinaryService.instance && config) {
      CloudinaryService.instance = new CloudinaryService(config);
    }
    return CloudinaryService.instance;
  }

  async uploadImage(
    file: Express.Multer.File,
    options?: {
      folder?: string;
      transformation?: any[];
      tags?: string[];
    }
  ): Promise<{
    url: string;
    thumbnailUrl: string;
    publicId: string;
    width: number;
    height: number;
  }> {
    try {
      const result = await cloudinary.uploader.upload(file.path, {
        folder: options?.folder || 'clst',
        tags: options?.tags,
        transformation: options?.transformation,
        resource_type: 'image',
        allowed_formats: ['jpg', 'jpeg', 'png', 'webp'],
        max_file_size: 10 * 1024 * 1024, // 10MB
      });

      // Generate thumbnail URL
      const thumbnailUrl = cloudinary.url(result.public_id, {
        width: 300,
        height: 300,
        crop: 'fill',
        gravity: 'center',
        quality: 'auto',
        fetch_format: 'auto',
      });

      return {
        url: result.secure_url,
        thumbnailUrl,
        publicId: result.public_id,
        width: result.width,
        height: result.height,
      };
    } catch (error) {
      throw new Error(`Failed to upload image: ${error.message}`);
    }
  }

  async uploadMultiple(
    files: Express.Multer.File[],
    options?: any
  ): Promise<any[]> {
    const uploadPromises = files.map(file => this.uploadImage(file, options));
    return Promise.all(uploadPromises);
  }

  async deleteImage(publicId: string): Promise<void> {
    try {
      await cloudinary.uploader.destroy(publicId);
    } catch (error) {
      throw new Error(`Failed to delete image: ${error.message}`);
    }
  }

  async deleteMultiple(publicIds: string[]): Promise<void> {
    try {
      await cloudinary.api.delete_resources(publicIds);
    } catch (error) {
      throw new Error(`Failed to delete images: ${error.message}`);
    }
  }

  generateOptimizedUrl(
    publicId: string,
    options: {
      width?: number;
      height?: number;
      quality?: number | 'auto';
      format?: string | 'auto';
    }
  ): string {
    return cloudinary.url(publicId, {
      ...options,
      crop: 'fill',
      gravity: 'center',
      fetch_format: options.format || 'auto',
    });
  }
}

// Frontend integration
// src/shared/services/upload/uploadService.ts
export class UploadService {
  private static instance: UploadService;
  private uploadUrl: string;

  constructor() {
    this.uploadUrl = import.meta.env.VITE_UPLOAD_URL || '/api/upload';
  }

  static getInstance(): UploadService {
    if (!UploadService.instance) {
      UploadService.instance = new UploadService();
    }
    return UploadService.instance;
  }

  async uploadImage(file: File, onProgress?: (progress: number) => void): Promise<{
    url: string;
    thumbnailUrl: string;
    id: string;
  }> {
    const formData = new FormData();
    formData.append('image', file);

    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable && onProgress) {
          const progress = Math.round((e.loaded / e.total) * 100);
          onProgress(progress);
        }
      });

      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch (error) {
            reject(new Error('Invalid response format'));
          }
        } else {
          reject(new Error(`Upload failed: ${xhr.statusText}`));
        }
      });

      xhr.addEventListener('error', () => {
        reject(new Error('Upload failed'));
      });

      xhr.open('POST', this.uploadUrl);
      
      // Add auth token if available
      const token = localStorage.getItem('clst_auth_token');
      if (token) {
        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
      }

      xhr.send(formData);
    });
  }

  async uploadMultiple(
    files: File[],
    onProgress?: (progress: number, fileIndex: number) => void
  ): Promise<any[]> {
    const uploads = files.map((file, index) =>
      this.uploadImage(file, (progress) => onProgress?.(progress, index))
    );
    return Promise.all(uploads);
  }

  validateFile(file: File): { valid: boolean; error?: string } {
    const maxSize = 10 * 1024 * 1024; // 10MB
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];

    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: 'Invalid file type. Please upload JPEG, PNG, or WebP.' };
    }

    if (file.size > maxSize) {
      return { valid: false, error: 'File too large. Maximum size is 10MB.' };
    }

    return { valid: true };
  }
}

// ===== WEATHER API INTEGRATION =====
// src/shared/services/weather/weatherService.ts
interface WeatherData {
  temp: {
    current: number;
    min: number;
    max: number;
    feels_like: number;
  };
  condition: string;
  description: string;
  humidity: number;
  wind_speed: number;
  precipitation: number;
  uv_index: number;
  icon: string;
}

export class WeatherService {
  private apiKey: string;
  private baseUrl = 'https://api.openweathermap.org/data/2.5';
  private cache = new Map<string, { data: WeatherData; timestamp: number }>();
  private cacheTimeout = 30 * 60 * 1000; // 30 minutes

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async getCurrentWeather(lat: number, lon: number): Promise<WeatherData> {
    const cacheKey = `current_${lat}_${lon}`;
    const cached = this.getFromCache(cacheKey);
    if (cached) return cached;

    try {
      const response = await fetch(
        `${this.baseUrl}/weather?lat=${lat}&lon=${lon}&appid=${this.apiKey}&units=metric`
      );

      if (!response.ok) {
        throw new Error('Failed to fetch weather data');
      }

      const data = await response.json();
      const weatherData = this.parseWeatherData(data);
      
      this.setCache(cacheKey, weatherData);
      return weatherData;
    } catch (error) {
      throw new Error(`Weather API error: ${error.message}`);
    }
  }

  async getForecast(lat: number, lon: number, days: number = 7): Promise<WeatherData[]> {
    const cacheKey = `forecast_${lat}_${lon}_${days}`;
    const cached = this.getFromCache(cacheKey);
    if (cached) return cached;

    try {
      const response = await fetch(
        `${this.baseUrl}/forecast/daily?lat=${lat}&lon=${lon}&cnt=${days}&appid=${this.apiKey}&units=metric`
      );

      if (!response.ok) {
        throw new Error('Failed to fetch forecast data');
      }

      const data = await response.json();
      const forecast = data.list.map(this.parseWeatherData);
      
      this.setCache(cacheKey, forecast);
      return forecast;
    } catch (error) {
      throw new Error(`Weather API error: ${error.message}`);
    }
  }

  private parseWeatherData(data: any): WeatherData {
    return {
      temp: {
        current: data.main?.temp || data.temp?.day,
        min: data.main?.temp_min || data.temp?.min,
        max: data.main?.temp_max || data.temp?.max,
        feels_like: data.main?.feels_like || data.feels_like?.day,
      },
      condition: this.mapCondition(data.weather?.[0]?.main),
      description: data.weather?.[0]?.description || '',
      humidity: data.main?.humidity || data.humidity || 0,
      wind_speed: data.wind?.speed || 0,
      precipitation: data.rain?.['1h'] || data.rain || 0,
      uv_index: data.uvi || 0,
      icon: data.weather?.[0]?.icon || '',
    };
  }

  private mapCondition(condition: string): string {
    const conditionMap: Record<string, string> = {
      'Clear': 'sunny',
      'Clouds': 'cloudy',
      'Rain': 'rainy',
      'Drizzle': 'rainy',
      'Thunderstorm': 'rainy',
      'Snow': 'snowy',
      'Mist': 'cloudy',
      'Fog': 'cloudy',
    };
    return conditionMap[condition] || 'cloudy';
  }

  private getFromCache(key: string): any | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    const age = Date.now() - cached.timestamp;
    if (age > this.cacheTimeout) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  private setCache(key: string, data: any): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    });
  }

  getOutfitSuggestions(weather: WeatherData): string[] {
    const suggestions: string[] = [];
    const { temp, condition, wind_speed, precipitation } = weather;

    // Temperature-based suggestions
    if (temp.current < 10) {
      suggestions.push('Heavy coat', 'Warm layers', 'Boots', 'Scarf');
    } else if (temp.current < 20) {
      suggestions.push('Light jacket', 'Long pants', 'Closed shoes');
    } else if (temp.current < 25) {
      suggestions.push('T-shirt', 'Light pants or shorts');
    } else {
      suggestions.push('Light clothing', 'Shorts', 'Sandals');
    }

    // Condition-based suggestions
    if (condition === 'rainy') {
      suggestions.push('Waterproof jacket', 'Umbrella', 'Water-resistant shoes');
    } else if (condition === 'sunny' && weather.uv_index > 6) {
      suggestions.push('Sunglasses', 'Hat', 'Sunscreen');
    }

    // Wind-based suggestions
    if (wind_speed > 20) {
      suggestions.push('Windbreaker', 'Secure accessories');
    }

    return suggestions;
  }
}

// Frontend hook
// src/features/outfits/hooks/useWeather.ts
import { useQuery } from '@tanstack/react-query';
import { useGeolocation } from '@/shared/hooks/useGeolocation';
import { WeatherService } from '@/shared/services/weather/weatherService';

const weatherService = new WeatherService(import.meta.env.VITE_WEATHER_API_KEY);

export function useWeather() {
  const { coords, error: geoError } = useGeolocation();

  const { data: currentWeather, isLoading: isLoadingCurrent } = useQuery({
    queryKey: ['weather', 'current', coords?.latitude, coords?.longitude],
    queryFn: () => weatherService.getCurrentWeather(coords!.latitude, coords!.longitude),
    enabled: !!coords,
    staleTime: 30 * 60 * 1000, // 30 minutes
  });

  const { data: forecast, isLoading: isLoadingForecast } = useQuery({
    queryKey: ['weather', 'forecast', coords?.latitude, coords?.longitude],
    queryFn: () => weatherService.getForecast(coords!.latitude, coords!.longitude),
    enabled: !!coords,
    staleTime: 60 * 60 * 1000, // 1 hour
  });

  return {
    currentWeather,
    forecast,
    isLoading: isLoadingCurrent || isLoadingForecast,
    error: geoError,
    suggestions: currentWeather ? weatherService.getOutfitSuggestions(currentWeather) : [],
  };
}

// ===== TESTING =====
// src/tests/setup.ts
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, vi } from 'vitest';

afterEach(() => {
  cleanup();
});

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
};

// Unit Tests
// src/features/auth/stores/__tests__/auth.store.test.ts
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useAuthStore } from '../auth.store';
import { authApi } from '../../api/auth.api';

vi.mock('../../api/auth.api');

describe('AuthStore', () => {
  beforeEach(() => {
    const { result } = renderHook(() => useAuthStore());
    act(() => {
      result.current.logout();
    });
  });

  it('should handle login successfully', async () => {
    const mockUser = { id: '1', email: 'test@example.com' };
    const mockTokens = { 
      accessToken: 'access123', 
      refreshToken: 'refresh123',
      expiresIn: 3600 
    };

    vi.mocked(authApi.login).mockResolvedValueOnce({
      user: mockUser,
      tokens: mockTokens,
    });

    const { result } = renderHook(() => useAuthStore());

    await act(async () => {
      await result.current.login({
        email: 'test@example.com',
        password: 'password123',
      });
    });

    expect(result.current.user).toEqual(mockUser);
    expect(result.current.isAuthenticated).toBe(true);
    expect(result.current.tokens).toEqual(mockTokens);
  });

  it('should handle login failure', async () => {
    const errorMessage = 'Invalid credentials';
    vi.mocked(authApi.login).mockRejectedValueOnce(new Error(errorMessage));

    const { result } = renderHook(() => useAuthStore());

    await act(async () => {
      try {
        await result.current.login({
          email: 'test@example.com',
          password: 'wrongpassword',
        });
      } catch (error) {
        // Expected error
      }
    });

    expect(result.current.user).toBeNull();
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.error).toBe(errorMessage);
  });

  it('should clear user data on logout', async () => {
    const { result } = renderHook(() => useAuthStore());
    
    // Set some initial state
    act(() => {
      result.current.user = { id: '1', email: 'test@example.com' };
      result.current.isAuthenticated = true;
    });

    await act(async () => {
      await result.current.logout();
    });

    expect(result.current.user).toBeNull();
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.tokens).toBeNull();
  });
});

// Component Tests
// src/features/closet/components/__tests__/ItemCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { BrowserRouter } from 'react-router-dom';
import { ItemCard } from '../ItemCard';

const mockItem = {
  id: '1',
  name: 'Test Shirt',
  category: 'tops',
  brand: 'Test Brand',
  size: 'M',
  images: [{ id: '1', url: '/test.jpg', thumbnailUrl: '/test-thumb.jpg', isPrimary: true }],
  wearCount: 5,
  price: 29.99,
  tags: ['casual', 'summer'],
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
};

const renderWithRouter = (component: React.ReactElement) => {
  return render(<BrowserRouter>{component}</BrowserRouter>);
};

describe('ItemCard', () => {
  it('renders item information correctly', () => {
    renderWithRouter(<ItemCard item={mockItem} />);

    expect(screen.getByText('Test Shirt')).toBeInTheDocument();
    expect(screen.getByText(/Test Brand/)).toBeInTheDocument();
    expect(screen.getByText(/Worn 5 times/)).toBeInTheDocument();
    expect(screen.getByText('$29.99')).toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', () => {
    const onEdit = vi.fn();
    renderWithRouter(<ItemCard item={mockItem} onEdit={onEdit} />);

    const editButton = screen.getByLabelText('Edit item');
    fireEvent.click(editButton);

    expect(onEdit).toHaveBeenCalledTimes(1);
  });

  it('shows selection checkbox when onSelect is provided', () => {
    const onSelect = vi.fn();
    renderWithRouter(<ItemCard item={mockItem} onSelect={onSelect} />);

    const checkbox = screen.getByRole('checkbox');
    expect(checkbox).toBeInTheDocument();

    fireEvent.click(checkbox);
    expect(onSelect).toHaveBeenCalledWith(true);
  });

  it('renders correctly in list view', () => {
    renderWithRouter(<ItemCard item={mockItem} viewMode="list" />);

    // In list view, we should see a different layout
    expect(screen.getByText('Test Shirt')).toBeInTheDocument();
    expect(screen.getByText(/Test Brand/)).toBeInTheDocument();
  });
});

// Integration Tests
// src/features/marketplace/__tests__/marketplace.integration.test.tsx
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { BrowserRouter } from 'react-router-dom';
import MarketplacePage from '../pages/MarketplacePage';
import { marketplaceApi } from '../api/marketplace.api';

vi.mock('../api/marketplace.api');

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });

  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>{children}</BrowserRouter>
    </QueryClientProvider>
  );
};

describe('Marketplace Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('loads and displays listings', async () => {
    const mockListings = [
      {
        id: '1',
        title: 'Vintage T-Shirt',
        price: 25,
        images: [{ url: '/img1.jpg', isPrimary: true }],
        seller: { username: 'seller1' },
      },
      {
        id: '2',
        title: 'Designer Jeans',
        price: 80,
        images: [{ url: '/img2.jpg', isPrimary: true }],
        seller: { username: 'seller2' },
      },
    ];

    vi.mocked(marketplaceApi.getListings).mockResolvedValueOnce({
      data: mockListings,
      meta: { page: 1, totalPages: 1, total: 2, limit: 24 },
    });

    render(<MarketplacePage />, { wrapper: createWrapper() });

    await waitFor(() => {
      expect(screen.getByText('Vintage T-Shirt')).toBeInTheDocument();
      expect(screen.getByText('Designer Jeans')).toBeInTheDocument();
    });
  });

  it('filters listings based on search', async () => {
    vi.mocked(marketplaceApi.getListings).mockResolvedValueOnce({
      data: [],
      meta: { page: 1, totalPages: 1, total: 0, limit: 24 },
    });

    render(<MarketplacePage />, { wrapper: createWrapper() });

    const searchInput = screen.getByPlaceholderText('Search listings...');
    fireEvent.change(searchInput, { target: { value: 'vintage' } });

    await waitFor(() => {
      expect(marketplaceApi.getListings).toHaveBeenCalledWith(
        expect.objectContaining({
          search: 'vintage',
        })
      );
    });
  });
});

// ===== ANALYTICS =====
// src/shared/services/analytics/analyticsService.ts
interface AnalyticsEvent {
  category: string;
  action: string;
  label?: string;
  value?: number;
  userId?: string;
  sessionId?: string;
  metadata?: Record<string, any>;
}

export class AnalyticsService {
  private queue: AnalyticsEvent[] = [];
  private sessionId: string;
  private userId?: string;
  private isInitialized = false;

  constructor() {
    this.sessionId = this.generateSessionId();
    this.startHeartbeat();
  }

  initialize(config: { userId?: string; [key: string]: any }) {
    this.userId = config.userId;
    this.isInitialized = true;

    // Initialize third-party analytics
    if (typeof window !== 'undefined') {
      // Google Analytics
      if (window.gtag && import.meta.env.VITE_GA_ID) {
        window.gtag('config', import.meta.env.VITE_GA_ID, {
          user_id: config.userId,
          custom_map: {
            dimension1: 'user_type',
            dimension2: 'session_id',
          },
        });
      }

      // Mixpanel
      if (window.mixpanel && import.meta.env.VITE_MIXPANEL_TOKEN) {
        window.mixpanel.init(import.meta.env.VITE_MIXPANEL_TOKEN);
        if (config.userId) {
          window.mixpanel.identify(config.userId);
          window.mixpanel.people.set(config);
        }
      }
    }

    // Process queued events
    this.flushQueue();
  }

  track(event: Omit<AnalyticsEvent, 'userId' | 'sessionId'>) {
    const fullEvent: AnalyticsEvent = {
      ...event,
      userId: this.userId,
      sessionId: this.sessionId,
      timestamp: new Date().toISOString(),
    };

    if (!this.isInitialized) {
      this.queue.push(fullEvent);
      return;
    }

    this.sendEvent(fullEvent);
  }

  trackPageView(path: string, title?: string) {
    this.track({
      category: 'Navigation',
      action: 'page_view',
      label: path,
      metadata: { title },
    });

    // Google Analytics
    if (window.gtag) {
      window.gtag('event', 'page_view', {
        page_path: path,
        page_title: title,
      });
    }
  }

  trackUserBehavior(behavior: {
    action: string;
    target: string;
    value?: any;
    context?: Record<string, any>;
  }) {
    this.track({
      category: 'User Behavior',
      action: behavior.action,
      label: behavior.target,
      value: behavior.value,
      metadata: behavior.context,
    });
  }

  trackPerformance(metric: {
    name: string;
    value: number;
    unit: string;
    metadata?: Record<string, any>;
  }) {
    this.track({
      category: 'Performance',
      action: 'metric',
      label: metric.name,
      value: metric.value,
      metadata: {
        unit: metric.unit,
        ...metric.metadata,
      },
    });
  }

  trackError(error: {
    message: string;
    stack?: string;
    context?: Record<string, any>;
  }) {
    this.track({
      category: 'Error',
      action: 'error_occurred',
      label: error.message,
      metadata: {
        stack: error.stack,
        ...error.context,
      },
    });
  }

  private sendEvent(event: AnalyticsEvent) {
    // Send to internal analytics API
    fetch('/api/analytics/events', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(event),
    }).catch(console.error);

    // Send to third-party services
    if (window.gtag) {
      window.gtag('event', event.action, {
        event_category: event.category,
        event_label: event.label,
        value: event.value,
        ...event.metadata,
      });
    }

    if (window.mixpanel) {
      window.mixpanel.track(`${event.category}_${event.action}`, {
        label: event.label,
        value: event.value,
        ...event.metadata,
      });
    }
  }

  private flushQueue() {
    while (this.queue.length > 0) {
      const event = this.queue.shift();
      if (event) {
        this.sendEvent(event);
      }
    }
  }

  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private startHeartbeat() {
    // Send heartbeat every 30 seconds to track active users
    setInterval(() => {
      if (this.isInitialized) {
        this.track({
          category: 'System',
          action: 'heartbeat',
          metadata: {
            timestamp: new Date().toISOString(),
          },
        });
      }
    }, 30000);
  }

  // Feature-specific tracking methods
  trackClosetAction(action: 'add' | 'edit' | 'delete' | 'view', itemData?: any) {
    this.track({
      category: 'Closet',
      action: `item_${action}`,
      metadata: itemData,
    });
  }

  trackMarketplaceAction(action: string, listingData?: any) {
    this.track({
      category: 'Marketplace',
      action,
      metadata: listingData,
    });
  }

  trackChallengeAction(action: string, challengeData?: any) {
    this.track({
      category: 'Challenge',
      action,
      metadata: challengeData,
    });
  }
}

export const analytics = new AnalyticsService();

// React hook for analytics
// src/shared/hooks/useAnalytics.ts
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import { analytics } from '@/shared/services/analytics/analyticsService';
import { useAuthStore } from '@/features/auth/stores/auth.store';

export function useAnalytics() {
  const location = useLocation();
  const user = useAuthStore(state => state.user);

  // Initialize analytics with user data
  useEffect(() => {
    if (user) {
      analytics.initialize({
        userId: user.id,
        email: user.email,
        username: user.username,
      });
    }
  }, [user]);

  // Track page views
  useEffect(() => {
    analytics.trackPageView(location.pathname);
  }, [location]);

  return {
    track: analytics.track.bind(analytics),
    trackUserBehavior: analytics.trackUserBehavior.bind(analytics),
    trackPerformance: analytics.trackPerformance.bind(analytics),
    trackError: analytics.trackError.bind(analytics),
    trackClosetAction: analytics.trackClosetAction.bind(analytics),
    trackMarketplaceAction: analytics.trackMarketplaceAction.bind(analytics),
    trackChallengeAction: analytics.trackChallengeAction.bind(analytics),
  };
}
