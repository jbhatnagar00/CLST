// src/shared/components/ui/VirtualGrid/VirtualGrid.tsx
import React, { useRef, useCallback, useEffect } from 'react';
import { VariableSizeGrid as Grid } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import { useInfiniteQuery } from '@tanstack/react-query';

interface VirtualGridProps<T> {
  items: T[];
  renderItem: (item: T, style: React.CSSProperties) => React.ReactNode;
  columnCount: number;
  rowHeight: number;
  gap?: number;
  loadMore?: () => Promise<{ items: T[]; hasMore: boolean }>;
  threshold?: number;
  className?: string;
}

export function VirtualGrid<T extends { id: string }>({
  items,
  renderItem,
  columnCount,
  rowHeight,
  gap = 16,
  loadMore,
  threshold = 5,
  className,
}: VirtualGridProps<T>) {
  const gridRef = useRef<Grid>(null);
  const loadingRef = useRef(false);

  const getColumnWidth = useCallback((width: number) => {
    return (width - gap * (columnCount - 1)) / columnCount;
  }, [columnCount, gap]);

  const getRowCount = useCallback(() => {
    return Math.ceil(items.length / columnCount);
  }, [items.length, columnCount]);

  const Cell = useCallback(({ columnIndex, rowIndex, style }: any) => {
    const index = rowIndex * columnCount + columnIndex;
    if (index >= items.length) return null;

    const item = items[index];
    const adjustedStyle = {
      ...style,
      left: style.left + columnIndex * gap,
      top: style.top + rowIndex * gap,
      width: style.width - gap,
      height: style.height - gap,
    };

    return renderItem(item, adjustedStyle);
  }, [items, columnCount, gap, renderItem]);

  const handleScroll = useCallback(async ({ scrollTop, scrollHeight, clientHeight }: any) => {
    if (!loadMore || loadingRef.current) return;

    const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
    const rowCount = getRowCount();
    const visibleRows = Math.ceil(clientHeight / (rowHeight + gap));
    const scrolledRows = Math.floor(scrollTop / (rowHeight + gap));
    
    if (scrolledRows + visibleRows >= rowCount - threshold) {
      loadingRef.current = true;
      try {
        await loadMore();
      } finally {
        loadingRef.current = false;
      }
    }
  }, [loadMore, threshold, getRowCount, rowHeight, gap]);

  return (
    <AutoSizer className={className}>
      {({ height, width }) => (
        <Grid
          ref={gridRef}
          columnCount={columnCount}
          columnWidth={() => getColumnWidth(width)}
          height={height}
          rowCount={getRowCount()}
          rowHeight={() => rowHeight}
          width={width}
          onScroll={handleScroll}
        >
          {Cell}
        </Grid>
      )}
    </AutoSizer>
  );
}

// src/shared/components/ui/ProgressiveImage/ProgressiveImage.tsx
import React, { useState, useEffect, useRef } from 'react';
import { cn } from '@/shared/utils/cn';

interface ProgressiveImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {
  src: string;
  placeholder?: string;
  thumbnailSrc?: string;
  onLoad?: () => void;
  onError?: () => void;
}

export const ProgressiveImage: React.FC<ProgressiveImageProps> = ({
  src,
  placeholder = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3Crect width="1" height="1" fill="%23f3f4f6"/%3E%3C/svg%3E',
  thumbnailSrc,
  onLoad,
  onError,
  className,
  alt,
  ...props
}) => {
  const [currentSrc, setCurrentSrc] = useState(placeholder);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  const observerRef = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    const img = imgRef.current;
    if (!img) return;

    // Set up Intersection Observer for lazy loading
    observerRef.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            loadImage();
            observerRef.current?.disconnect();
          }
        });
      },
      { rootMargin: '50px' }
    );

    observerRef.current.observe(img);

    return () => {
      observerRef.current?.disconnect();
    };
  }, [src, thumbnailSrc]);

  const loadImage = async () => {
    try {
      // Load thumbnail first if available
      if (thumbnailSrc && thumbnailSrc !== currentSrc) {
        await loadSrc(thumbnailSrc);
        setCurrentSrc(thumbnailSrc);
      }

      // Load full image
      await loadSrc(src);
      setCurrentSrc(src);
      setIsLoading(false);
      onLoad?.();
    } catch (err) {
      setError(true);
      setIsLoading(false);
      onError?.();
    }
  };

  const loadSrc = (src: string): Promise<void> => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve();
      img.onerror = reject;
    });
  };

  if (error) {
    return (
      <div className={cn('bg-gray-200 flex items-center justify-center', className)}>
        <span className="text-gray-400">Failed to load image</span>
      </div>
    );
  }

  return (
    <img
      ref={imgRef}
      src={currentSrc}
      alt={alt}
      className={cn(
        'transition-opacity duration-300',
        isLoading ? 'opacity-50' : 'opacity-100',
        className
      )}
      {...props}
    />
  );
};

// src/shared/services/cache/QueryCache.ts
import { QueryClient } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';
import { compress, decompress } from 'lz-string';

// Custom storage adapter with compression
const compressedStorage = {
  getItem: (key: string): string | null => {
    const compressed = localStorage.getItem(key);
    if (!compressed) return null;
    try {
      return decompress(compressed);
    } catch {
      return null;
    }
  },
  setItem: (key: string, value: string): void => {
    try {
      const compressed = compress(value);
      localStorage.setItem(key, compressed);
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  },
  removeItem: (key: string): void => {
    localStorage.removeItem(key);
  },
};

// IndexedDB adapter for large data
class IndexedDBAdapter {
  private dbName = 'clst-query-cache';
  private storeName = 'queries';
  private db: IDBDatabase | null = null;

  async init() {
    return new Promise<void>((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: 'key' });
        }
      };
    });
  }

  async getItem(key: string): Promise<string | null> {
    if (!this.db) await this.init();
    
    return new Promise((resolve) => {
      const transaction = this.db!.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(key);

      request.onsuccess = () => {
        const result = request.result;
        resolve(result ? result.value : null);
      };
      request.onerror = () => resolve(null);
    });
  }

  async setItem(key: string, value: string): Promise<void> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.put({ key, value });

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async removeItem(key: string): Promise<void> {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(key);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

// Create query client with advanced caching
export const createQueryClient = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 24 * 60 * 60 * 1000, // 24 hours
        retry: (failureCount, error: any) => {
          if (error?.status === 404) return false;
          return failureCount < 3;
        },
        refetchOnWindowFocus: false,
        refetchOnReconnect: 'always',
      },
    },
  });

  // Set up persistence
  const persister = createSyncStoragePersister({
    storage: compressedStorage,
    throttleTime: 1000,
  });

  persistQueryClient({
    queryClient,
    persister,
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    hydrateOptions: {},
    dehydrateOptions: {
      shouldDehydrateQuery: (query) => {
        const queryKey = query.queryKey;
        // Don't persist sensitive data
        if (queryKey.includes('auth') || queryKey.includes('payment')) {
          return false;
        }
        return query.state.status === 'success';
      },
    },
  });

  return queryClient;
};

// src/shared/hooks/useInfiniteScroll.ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { useCallback, useEffect, useRef } from 'react';

interface UseInfiniteScrollOptions<T> {
  queryKey: any[];
  queryFn: ({ pageParam }: { pageParam: number }) => Promise<{
    data: T[];
    meta: {
      page: number;
      totalPages: number;
      total: number;
    };
  }>;
  getNextPageParam?: (lastPage: any, pages: any[]) => number | undefined;
}

export function useInfiniteScroll<T>({
  queryKey,
  queryFn,
  getNextPageParam = (lastPage) => {
    const { page, totalPages } = lastPage.meta;
    return page < totalPages ? page + 1 : undefined;
  },
}: UseInfiniteScrollOptions<T>) {
  const observerRef = useRef<IntersectionObserver | null>(null);
  const loadMoreRef = useRef<HTMLDivElement>(null);

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    error,
  } = useInfiniteQuery({
    queryKey,
    queryFn,
    getNextPageParam,
    initialPageParam: 1,
  });

  useEffect(() => {
    const element = loadMoreRef.current;
    if (!element) return;

    observerRef.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {
          fetchNextPage();
        }
      },
      { threshold: 0.1, rootMargin: '100px' }
    );

    observerRef.current.observe(element);

    return () => {
      observerRef.current?.disconnect();
    };
  }, [hasNextPage, isFetchingNextPage, fetchNextPage]);

  const items = data?.pages.flatMap(page => page.data) ?? [];

  return {
    items,
    isLoading,
    error,
    hasNextPage,
    isFetchingNextPage,
    loadMoreRef,
  };
}

// src/shared/utils/performance.ts
// Debounce with request animation frame
export function rafDebounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  let rafId: number | null = null;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      if (rafId) {
        cancelAnimationFrame(rafId);
      }
      rafId = requestAnimationFrame(() => {
        func(...args);
      });
    };

    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}

// Memory-efficient image preloader
export class ImagePreloader {
  private cache = new Map<string, Promise<void>>();
  private loadingCount = 0;
  private maxConcurrent = 3;
  private queue: string[] = [];

  preload(urls: string[]): Promise<void[]> {
    const promises = urls.map(url => this.loadImage(url));
    return Promise.all(promises);
  }

  private async loadImage(url: string): Promise<void> {
    // Check cache
    if (this.cache.has(url)) {
      return this.cache.get(url)!;
    }

    // Queue if too many concurrent loads
    if (this.loadingCount >= this.maxConcurrent) {
      return new Promise((resolve) => {
        this.queue.push(url);
        const checkQueue = setInterval(() => {
          if (this.loadingCount < this.maxConcurrent) {
            clearInterval(checkQueue);
            this.loadImage(url).then(resolve);
          }
        }, 100);
      });
    }

    // Create loading promise
    const promise = new Promise<void>((resolve, reject) => {
      this.loadingCount++;
      const img = new Image();
      
      img.onload = () => {
        this.loadingCount--;
        this.processQueue();
        resolve();
      };
      
      img.onerror = () => {
        this.loadingCount--;
        this.processQueue();
        reject(new Error(`Failed to load image: ${url}`));
      };
      
      img.src = url;
    });

    this.cache.set(url, promise);
    return promise;
  }

  private processQueue() {
    if (this.queue.length > 0 && this.loadingCount < this.maxConcurrent) {
      const url = this.queue.shift()!;
      this.loadImage(url);
    }
  }

  clear() {
    this.cache.clear();
    this.queue = [];
  }
}

// Performance monitoring
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  measure(name: string, fn: () => void): void {
    const start = performance.now();
    fn();
    const end = performance.now();
    
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    this.metrics.get(name)!.push(end - start);
    
    // Keep only last 100 measurements
    const measurements = this.metrics.get(name)!;
    if (measurements.length > 100) {
      measurements.shift();
    }
  }

  async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    try {
      const result = await fn();
      const end = performance.now();
      
      if (!this.metrics.has(name)) {
        this.metrics.set(name, []);
      }
      
      this.metrics.get(name)!.push(end - start);
      
      return result;
    } catch (error) {
      throw error;
    }
  }

  getMetrics(name: string): {
    avg: number;
    min: number;
    max: number;
    count: number;
  } | null {
    const measurements = this.metrics.get(name);
    if (!measurements || measurements.length === 0) {
      return null;
    }

    const sum = measurements.reduce((a, b) => a + b, 0);
    const avg = sum / measurements.length;
    const min = Math.min(...measurements);
    const max = Math.max(...measurements);

    return { avg, min, max, count: measurements.length };
  }

  logMetrics() {
    console.group('Performance Metrics');
    this.metrics.forEach((measurements, name) => {
      const metrics = this.getMetrics(name);
      if (metrics) {
        console.log(
          `${name}: avg=${metrics.avg.toFixed(2)}ms, min=${metrics.min.toFixed(2)}ms, max=${metrics.max.toFixed(2)}ms, count=${metrics.count}`
        );
      }
    });
    console.groupEnd();
  }

  clear() {
    this.metrics.clear();
  }
}

// Bundle size optimization - Dynamic imports
export const lazyImport = <T extends React.ComponentType<any>>(
  importFn: () => Promise<{ default: T }>
): React.LazyExoticComponent<T> => {
  return React.lazy(importFn);
};

// Optimized hook for closet items with virtual scrolling
// src/features/closet/hooks/useOptimizedCloset.ts
import { useCallback, useMemo } from 'react';
import { useInfiniteScroll } from '@/shared/hooks/useInfiniteScroll';
import { closetApi } from '../api/closet.api';
import type { ClothingItem } from '../types';

export function useOptimizedCloset(filters?: any) {
  const {
    items,
    isLoading,
    error,
    hasNextPage,
    isFetchingNextPage,
    loadMoreRef,
  } = useInfiniteScroll<ClothingItem>({
    queryKey: ['closet-items-infinite', filters],
    queryFn: async ({ pageParam }) => {
      return closetApi.getItems({
        page: pageParam,
        limit: 50,
        ...filters,
      });
    },
  });

  // Memoized filtered items
  const filteredItems = useMemo(() => {
    return items.filter(item => {
      // Apply client-side filters if needed
      return true;
    });
  }, [items]);

  // Virtual grid configuration
  const gridConfig = useMemo(() => {
    const width = window.innerWidth;
    let columnCount = 2;
    
    if (width >= 1536) columnCount = 6;
    else if (width >= 1280) columnCount = 5;
    else if (width >= 1024) columnCount = 4;
    else if (width >= 768) columnCount = 3;
    
    return {
      columnCount,
      rowHeight: width < 768 ? 200 : 280,
      gap: 16,
    };
  }, []);

  return {
    items: filteredItems,
    isLoading,
    error,
    hasNextPage,
    isFetchingNextPage,
    loadMoreRef,
    gridConfig,
  };
}

// Error tracking service
// src/shared/services/errorTracking.ts
interface ErrorContext {
  userId?: string;
  action?: string;
  component?: string;
  extra?: Record<string, any>;
}

class ErrorTracker {
  private queue: Array<{ error: Error; context: ErrorContext }> = [];
  private isOnline = navigator.onLine;

  constructor() {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.flushQueue();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
    });

    // Global error handler
    window.addEventListener('error', (event) => {
      this.captureError(event.error, {
        component: 'global',
        extra: {
          message: event.message,
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
        },
      });
    });

    // Unhandled promise rejection
    window.addEventListener('unhandledrejection', (event) => {
      this.captureError(new Error(event.reason), {
        component: 'promise',
        extra: { reason: event.reason },
      });
    });
  }

  captureError(error: Error, context: ErrorContext = {}) {
    const errorData = {
      error,
      context: {
        ...context,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
      },
    };

    if (this.isOnline) {
      this.sendError(errorData);
    } else {
      this.queue.push(errorData);
    }

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error captured:', error, context);
    }
  }

  private async sendError(errorData: any) {
    try {
      // Send to error tracking service (e.g., Sentry)
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: errorData.error.name,
          message: errorData.error.message,
          stack: errorData.error.stack,
          context: errorData.context,
        }),
      });
    } catch (error) {
      console.error('Failed to send error:', error);
    }
  }

  private flushQueue() {
    while (this.queue.length > 0) {
      const errorData = this.queue.shift();
      if (errorData) {
        this.sendError(errorData);
      }
    }
  }
}

export const errorTracker = new ErrorTracker();
